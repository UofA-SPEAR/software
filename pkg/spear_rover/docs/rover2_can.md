# rover2_can

This file allows for an entry point to split code, like utility functions,
out of the main node file. It's generally a good idea to import functions from
this module, as other submodules might have a bunch of other internal functions
polluting your global namespace.

# rover2_can.util

## test_bit
```python
test_bit(number, offset)
```

Tests for the prescence of a bit at `offset` on `number`.
Returns True if it does exist, False if it doesn't.

## map_ros_to_can
```python
map_ros_to_can(ros_msg, ros_topic, uavcan_message_type, *mappings)
```

Subscribes to the specified ros_topic & message type, maps ros message data
from ros's format to UAVCAN's format using mapping functions specified in
`mappings`.

For example, imagine that you have a UAVCAN message named
`spear.led.BlinkCommand`, that takes a `blink_frequency` parameter, and a
ros message published to the `/led` topic called `LedPeriod` with a
parameter `period`. Someone told you to map the ros message's `period`
parameter to the UAVCAN message's `blink_frequency` parameter. Instead of
a whole lot of spaghetti code, you could do that with this function like
this:

```python
map_ros_to_can(LedPeriod, "/led", "spear.led.BlinkCommand", {
    "blink_frequency": lambda data: 1 / data.period
})
```

__Arguments__


- __ros_msg (rospy.Message)__: The rospy-generated datatype for the ros message
you want it to subscribe to.

- __ros_topic (string)__: The name of the ros topic you want to
subscribe to, in the same format that the rest of ros uses.

- __uavcan_message_type (string)__: The name of the UAVCAN message you want to
publish, in the same format as described in UAVCAN's docs.

- __*mappings (list&lt;dict&gt;)__: Keys are the UAVCAN message parameters.
Values are functions that take one value (the ros message data) and
return a single value, which gets assigned to that UAVCAN message
parameter. If more than one mapping is passed, like with
```python
map_ros_to_can(RosMsg, "/rostopic", "uavcan.message",
    { ... mapping 1 ... }, { ... mapping 2 ... }, ...)
```
...then each mapping will receive the same RosMsg data, and each one
will publish a unique message to "uavcan.message". This is to deal
with cases where you might want to "split up" a single ros message into
multiple UAVCAN messages (of the same type), without wanting to create
several ros message subscribers (therefore saving memory).

## map_can_to_ros
```python
map_can_to_ros(uavcan_message_type, ros_message, ros_topic, *mappings)
```

Subscribes to the specified UAVCAN message type, and maps the data in each
received message of that type to the fields of the ROS message type given
in the `ros_message` parameter, using mapping functions given in the
`*mappings` parameters.

For example, imagine that you had a UAVCAN message called
`spear.led.BlinkStatus` with a single field, `blink_count`. You want to
publish the blink count in thousands of blinks using the ROS message
`LedBlinkStatus` to the ROS topic `/led`. One way you could do that with
this function is as follows:

```python
map_can_to_ros('spear.led.BlinkStatus', LedBlinkStatus, '/led', {
    'thousands_of_blinks': lambda data: data.blink_count / 1000
})
```

__Arguments__


- __uavcan_message_type (string)__: The UAVCAN message type.

- __ros_message (rospy.Message)__: The ROS message class as generated by catkin
when building everything.

- __ros_topic (string)__: The ros topic to publish to.

- __*mappings (list&lt;dict&gt;)__: Dictionaries of mappings from UAVCAN messages
to the specified ROS message type. The keys of the dictionaries are the ROS
parameters, and the keys are the mapping functions. Each mapping function
recieves a single argument, `data`, which contains all of the UAVCAN
message data. The ROS parameter will be set to whatever the mapping
function returns. If more than one dictionary of mappings is passed,
then each one will recieve the same data object in its mapping functions
and will trigger one ROS message being sent. This allows for "splitting"
a single UAVCAN message into multiple ROS messages. See the docs for
[`rover2_can.util.map_ros_to_can()`](#map_ros_to_can) for more details.

