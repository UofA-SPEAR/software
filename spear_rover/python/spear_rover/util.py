# Utility functions.

from typing import Any, Callable, Dict, List, Tuple, Type, TypeVar

import canros
import rospy


def test_bit(number, offset):  # type: (int, int) -> int
    """
    Tests for the prescence of a bit at `offset` on `number`.
    Returns True if it does exist, False if it doesn't.
    """
    mask = 1 << offset
    result = True if (number & mask) > 0 else False
    return result


RosMessage = TypeVar('RosMessage')


def map_ros_to_can(
    ros_msg, ros_topic, uavcan_message_type, *mappings
):  # type: (Type[RosMessage], str, str, Dict[str, Callable[[RosMessage], List[canros.Message]]]) -> None
    """
    Subscribes to the specified ros_topic & message type, maps ros message data
    from ros's format to UAVCAN's format using mapping functions specified in
    `mappings`.

    For example, imagine that you have a UAVCAN message named
    `spear.led.BlinkCommand`, that takes a `blink_frequency` parameter, and a
    ros message published to the `/led` topic called `LedPeriod` with a
    parameter `period`. Someone told you to map the ros message's `period`
    parameter to the UAVCAN message's `blink_frequency` parameter. Instead of
    a whole lot of spaghetti code, you could do that with this function like
    this:

    ```python
    map_ros_to_can(LedPeriod, "/led", "spear.led.BlinkCommand", {
        "blink_frequency": lambda data: 1 / data.period
    })
    ```

    # Arguments

    ros_msg (rospy.Message): The rospy-generated datatype for the ros message
    you want it to subscribe to.

    ros_topic (string): The name of the ros topic you want to
    subscribe to, in the same format that the rest of ros uses.

    uavcan_message_type (string): The name of the UAVCAN message you want to
    publish, in the same format as described in UAVCAN's docs.

    *mappings (list&lt;dict&gt;): Keys are the UAVCAN message parameters.
    Values are functions that take one value (the ros message data) and
    return a single value, which gets assigned to that UAVCAN message
    parameter. If more than one mapping is passed, like with
    ```python
    map_ros_to_can(RosMsg, "/rostopic", "uavcan.message",
        { ... mapping 1 ... }, { ... mapping 2 ... }, ...)
    ```
    ...then each mapping will receive the same RosMsg data, and each one
    will publish a unique message to "uavcan.message". This is to deal
    with cases where you might want to "split up" a single ros message into
    multiple UAVCAN messages (of the same type), without wanting to create
    several ros message subscribers (therefore saving memory).
    """

    rospy.loginfo(
        "Mapping ros message {} on topic {} to UAVCAN message {}.".format(
            ros_msg._type, ros_topic, uavcan_message_type))

    can_msg = canros.Message(uavcan_message_type)
    pub = can_msg.Publisher(queue_size=10)
    msg = can_msg.Type()

    def cb(data):
        # Loop over the mappings & call the functions within to translate data
        # from the ros message to data on the can message.
        #
        # The keys of the mapping dictionary are used as the property name on
        # the can message.
        for mapping in mappings:
            msg = {key: mapper(data) for (key, mapper) in mapping.iteritems()}
            pub.publish(**msg)

    rospy.Subscriber(ros_topic, ros_msg, cb)


RosMessage = TypeVar('RosMessage')


def map_can_to_ros(
    uavcan_message_type, ros_message, ros_topic, *mappings
):  # type: (str, Type[RosMessage], str, Dict[str, Callable[[RosMessage], Any]]) -> None
    """
    Subscribes to the specified UAVCAN message type, and maps the data in each
    received message of that type to the fields of the ROS message type given
    in the `ros_message` parameter, using mapping functions given in the
    `*mappings` parameters.

    For example, imagine that you had a UAVCAN message called
    `spear.led.BlinkStatus` with a single field, `blink_count`. You want to
    publish the blink count in thousands of blinks using the ROS message
    `LedBlinkStatus` to the ROS topic `/led`. One way you could do that with
    this function is as follows:

    ```python
    map_can_to_ros('spear.led.BlinkStatus', LedBlinkStatus, '/led', {
        'thousands_of_blinks': lambda data: data.blink_count / 1000
    })
    ```

    # Arguments

    uavcan_message_type (string): The UAVCAN message type.

    ros_message (rospy.Message): The ROS message class as generated by catkin
    when building everything.

    ros_topic (string): The ros topic to publish to.

    *mappings (list<dict>): Dictionaries of mappings from UAVCAN messages
    to the specified ROS message type. The keys of the dictionaries are the ROS
    parameters, and the keys are the mapping functions. Each mapping function
    recieves a single argument, `data`, which contains all of the UAVCAN
    message data. The ROS parameter will be set to whatever the mapping
    function returns. If more than one dictionary of mappings is passed,
    then each one will recieve the same data object in its mapping functions
    and will trigger one ROS message being sent. This allows for "splitting"
    a single UAVCAN message into multiple ROS messages. See the docs for
    [`rover2_can.util.map_ros_to_can()`](#map_ros_to_can) for more details.
    """
    rospy.loginfo(
        "Mapping UAVCAN message {} to ros message {} on topic {}.".format(
            uavcan_message_type, ros_message._type, ros_topic))

    can_msg = canros.Message(uavcan_message_type)
    pub = rospy.Publisher(ros_topic, ros_message, queue_size=10)

    def cb(data):
        for mapping in mappings:
            message_payload = {
                key: mapper(data)
                for (key, mapper) in mapping.iteritems()
            }
            pub.publish(**message_payload)

    can_msg.Subscriber(callback=cb)
